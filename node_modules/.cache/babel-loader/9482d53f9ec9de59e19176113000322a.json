{"ast":null,"code":"export class AbstractRequestApi {\n  constructor() {\n    this.defaultHeader = {\n      Accept: 'application/json',\n      'Content-Type': 'application/json'\n    };\n  }\n\n  async _makeRequest(host, url, method, body, headers) {\n    const newHeaders = this._addHeader(headers);\n\n    try {\n      const response = await this.timeoutWrapper(this.getTimeout(), fetch(host + url, {\n        headers: newHeaders,\n        body: JSON.stringify(body),\n        method\n      }));\n\n      if (!response.ok) {\n        const errorMsg = await response.json();\n        throw new Error(response);\n      }\n\n      return response.json().then(data => this.checkForErrorData(data));\n    } catch (error) {\n      throw new Error(error);\n    }\n  }\n\n  getTimeout() {\n    return 5000;\n  }\n\n  checkForErrorData(data) {\n    if (data.errors) {\n      return Promise.reject(new Error(data.errors));\n    }\n\n    return data;\n  }\n\n  _addHeader(optionalHeaders) {\n    const headers = this.defaultHeader;\n\n    if (optionalHeaders) {\n      Object.keys(optionalHeaders).forEach(key => headers[key] = optionalHeaders[key]);\n    }\n\n    return headers;\n  }\n\n  timeoutWrapper(millis, promise) {\n    return new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        reject(new Error(\"Error\"));\n      }, millis);\n      promise.then(res => {\n        clearTimeout(timeoutId);\n        resolve(res);\n      }, err => {\n        clearTimeout(timeoutId);\n        reject(err);\n      });\n    });\n  }\n\n}","map":{"version":3,"sources":["/Users/ffaiku/opt/FH/4 Semester/Verteilte Systeme/Project/smart-home-ui/smart-home-ui/src/api/makeRequest.tsx"],"names":["AbstractRequestApi","defaultHeader","Accept","_makeRequest","host","url","method","body","headers","newHeaders","_addHeader","response","timeoutWrapper","getTimeout","fetch","JSON","stringify","ok","errorMsg","json","Error","then","data","checkForErrorData","error","errors","Promise","reject","optionalHeaders","Object","keys","forEach","key","millis","promise","resolve","timeoutId","setTimeout","res","clearTimeout","err"],"mappings":"AAEA,OAAO,MAAMA,kBAAN,CAAyB;AAAA;AAAA,SAE9BC,aAF8B,GAEd;AACdC,MAAAA,MAAM,EAAE,kBADM;AAEd,sBAAgB;AAFF,KAFc;AAAA;;AAO9B,QAAMC,YAAN,CAAsBC,IAAtB,EAAmCC,GAAnC,EAAgDC,MAAhD,EAAgEC,IAAhE,EAA4EC,OAA5E,EAAuG;AACrG,UAAMC,UAAU,GAAG,KAAKC,UAAL,CAAgBF,OAAhB,CAAnB;;AAEA,QAAI;AACF,YAAMG,QAAQ,GAAG,MAAM,KAAKC,cAAL,CACrB,KAAKC,UAAL,EADqB,EAErBC,KAAK,CAACV,IAAI,GAAGC,GAAR,EAAa;AAChBG,QAAAA,OAAO,EAAEC,UADO;AAEhBF,QAAAA,IAAI,EAAEQ,IAAI,CAACC,SAAL,CAAeT,IAAf,CAFU;AAGhBD,QAAAA;AAHgB,OAAb,CAFgB,CAAvB;;AASA,UAAI,CAACK,QAAQ,CAACM,EAAd,EAAkB;AAChB,cAAMC,QAAgB,GAAG,MAAMP,QAAQ,CAACQ,IAAT,EAA/B;AACA,cAAM,IAAIC,KAAJ,CAAUT,QAAV,CAAN;AACD;;AACD,aAAOA,QAAQ,CAACQ,IAAT,GAAgBE,IAAhB,CAAsBC,IAAD,IAAe,KAAKC,iBAAL,CAAuBD,IAAvB,CAApC,CAAP;AACD,KAfD,CAeE,OAAOE,KAAP,EAAc;AACd,YAAM,IAAIJ,KAAJ,CAAUI,KAAV,CAAN;AACD;AACF;;AAEDX,EAAAA,UAAU,GAAW;AACnB,WAAO,IAAP;AACD;;AAEDU,EAAAA,iBAAiB,CAACD,IAAD,EAAY;AAC3B,QAAIA,IAAI,CAACG,MAAT,EAAiB;AACf,aAAOC,OAAO,CAACC,MAAR,CAAe,IAAIP,KAAJ,CAAUE,IAAI,CAACG,MAAf,CAAf,CAAP;AACD;;AACD,WAAOH,IAAP;AACD;;AAEDZ,EAAAA,UAAU,CAACkB,eAAD,EAAkC;AAC1C,UAAMpB,OAAO,GAAG,KAAKP,aAArB;;AAEA,QAAI2B,eAAJ,EAAqB;AACnBC,MAAAA,MAAM,CAACC,IAAP,CAAYF,eAAZ,EAA6BG,OAA7B,CAAqCC,GAAG,IAAKxB,OAAO,CAACwB,GAAD,CAAP,GAAeJ,eAAe,CAACI,GAAD,CAA3E;AACD;;AACD,WAAOxB,OAAP;AACD;;AAGDI,EAAAA,cAAc,CAACqB,MAAD,EAAiBC,OAAjB,EAAwC;AACpD,WAAO,IAAIR,OAAJ,CAAY,CAACS,OAAD,EAAUR,MAAV,KAAqB;AACtC,YAAMS,SAAS,GAAGC,UAAU,CAAC,MAAM;AACjCV,QAAAA,MAAM,CAAC,IAAIP,KAAJ,CAAU,OAAV,CAAD,CAAN;AACD,OAF2B,EAEzBa,MAFyB,CAA5B;AAGAC,MAAAA,OAAO,CAACb,IAAR,CACEiB,GAAG,IAAI;AACLC,QAAAA,YAAY,CAACH,SAAD,CAAZ;AACAD,QAAAA,OAAO,CAACG,GAAD,CAAP;AACD,OAJH,EAKEE,GAAG,IAAI;AACLD,QAAAA,YAAY,CAACH,SAAD,CAAZ;AACAT,QAAAA,MAAM,CAACa,GAAD,CAAN;AACD,OARH;AAUD,KAdM,CAAP;AAeD;;AAnE6B","sourcesContent":["import { Method } from './ApiMethodEnum';\n\nexport class AbstractRequestApi {\n\n  defaultHeader = {\n    Accept: 'application/json',\n    'Content-Type': 'application/json',\n  };\n\n  async _makeRequest<T>(host:string, url: string, method: Method, body?: any, headers?: any): Promise<T> {\n    const newHeaders = this._addHeader(headers);\n\n    try {\n      const response = await this.timeoutWrapper(\n        this.getTimeout(),\n        fetch(host + url, {\n          headers: newHeaders,\n          body: JSON.stringify(body),\n          method,\n        })\n      );\n\n      if (!response.ok) {\n        const errorMsg: string = await response.json();\n        throw new Error(response);\n      }\n      return response.json().then((data: any) => this.checkForErrorData(data));\n    } catch (error) {\n      throw new Error(error);\n    }\n  }\n\n  getTimeout(): number {\n    return 5000;\n  }\n\n  checkForErrorData(data: any) {\n    if (data.errors) {\n      return Promise.reject(new Error(data.errors));\n    }\n    return data;\n  }\n\n  _addHeader(optionalHeaders?: string[]): any {\n    const headers = this.defaultHeader;\n\n    if (optionalHeaders) {\n      Object.keys(optionalHeaders).forEach(key => (headers[key] = optionalHeaders[key]));\n    }\n    return headers;\n  }\n\n\n  timeoutWrapper(millis: number, promise): Promise<any> {\n    return new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        reject(new Error(\"Error\"));\n      }, millis);\n      promise.then(\n        res => {\n          clearTimeout(timeoutId);\n          resolve(res);\n        },\n        err => {\n          clearTimeout(timeoutId);\n          reject(err);\n        }\n      );\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}